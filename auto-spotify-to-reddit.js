require('dotenv').config();
const spotifyWebApi = require('spotify-web-api-node');
const snoowrap = require('snoowrap');
const google = require('googleapis');
const fs = require('fs');
const stringSimilarity = require("string-similarity");

const reddit = new snoowrap({
  userAgent: process.env.R_USER_AGENT,
  clientId: process.env.R_CLIENT_ID,
  clientSecret: process.env.R_CLIENT_SECRET,
  refreshToken: process.env.R_REFRESH_TOKEN,
  username: process.env.R_USER,
  password: process.env.R_PASS
});

const spotify = new spotifyWebApi({
  clientId: process.env.S_CLIENT_ID,
  clientSecret: process.env.S_CLIENT_SECRET,
  refreshToken: process.env.S_REFRESH_TOKEN,
  redirectUri: 'http://localhost:8888/callback'
});

function getTimeStamp() {
  return new Date(Date.now()).toLocaleString();
}

function loadPostedTracks() {
  try {
    const data = fs.readFileSync('postedTracks.json', 'utf8');
    return JSON.parse(data) || [];
  } catch (error) {
    console.error('Error loading posted tracks:', error);
    return [];
  }
}

function savePostedTracks() {
  try {
    fs.writeFileSync('postedTracks.json', JSON.stringify(postedTracks), 'utf8');
  } catch (error) {
    console.error('Error saving posted tracks:', error);
  }
}

let postedTracks = loadPostedTracks();
let tracks = [];
spotify.setRefreshToken(process.env.S_REFRESH_TOKEN);

async function getGenre(artist) {
  try {
    if (artist != undefined) {
      const artistInfo = await spotify.getArtist(artist.id);

      if (artistInfo.body.genres.length > 0) {
        const genre = artistInfo.body.genres[0];
        return artistInfo.body.genres[0];
      } else {
        return 'indie';
      }
    } else {
      console.warn('No artist provided.');
      return null;
    }
  } catch (error) {
    console.error('Error:', error);
    return null;
  }
}

async function refreshTracksList() {
  await spotify.refreshAccessToken().then(
    function (data) {
      spotify.setAccessToken(data.body['access_token']);
    },
    function (err) {
      console.log('Could not refresh access token', err);
    }
  );

  return spotify.getPlaylistTracks(process.env.S_PLAYLIST).then(
    async function (data) {
      let temp = [];
      for (let i = 0; i < data.body.items.length; i++) {
        let track = data.body.items[i].track;

        if (postedTracks.includes(track.id)) {
          console.warn('Track', `${track.artists[0].name} - ${track.name}`, 'already posted; removing from playlist.')
          await removeTrackFromPlaylist(process.env.S_PLAYLIST, track.id);
        } else {
          console.log('Adding', track.artists[0].name, '-', track.name);

          let genre = await getGenre(track.artists[0])
          temp.push(`${track.artists[0].name} - ${track.name} [${genre}] (${track.album.release_date.substring(0, 4)}):${track.id}`);
        }
      }
      return temp;
    },
    function (err) {
      console.error(err);
    }
  );
}

async function removeTrackFromPlaylist(playlistId, trackId) {
  try {
    await spotify.removeTracksFromPlaylist(playlistId, [{ uri: `spotify:track:${trackId}` }]);
  } catch (error) {
    console.error('Error removing track:', error);
  }
}

async function searchYoutube(query) {
  const apiKey = process.env.Y_API_KEY;
  const apiUrl = "https://www.googleapis.com/youtube/v3/search";

  const maxResults = 1;

  const requestUrl = `${apiUrl}?part=snippet&q=${encodeURIComponent(query)}&maxResults=${maxResults}&key=${apiKey}`;

  try {
    const response = await fetch(requestUrl);
    const data = await response.json();

    if (response.ok) {
      const videos = data.items;
      let similarity = stringSimilarity.compareTwoStrings(videos[0].snippet.title, query);
      console.log(`Youtube returned ${videos[0].snippet.title}, has a similarity of ${similarity} to ${query}`);

      if (similarity <= 0.6) {
        // Retry comparison with channel name
        const withChannelTitle = videos[0].snippet.channelTitle.split('-')[0] + '- ' + videos[0].snippet.title;
        similarity = stringSimilarity.compareTwoStrings(withChannelTitle.toLowerCase(), query.toLowerCase());
        // Check with channel title, minus '- Topic' for autogenerated music channels
        console.log('With channel title, new similarity score is ', similarity, withChannelTitle);
      }

      if (similarity > 0.6) {
        return `https://www.youtube.com/watch?v=${videos[0].id.videoId}`;
      } else {
        return '';
      }
    } else {
      console.error(`Error: ${response.statusText}`);
      console.error(data);
    }
  } catch (error) {
    console.error("Error fetching data:", error);
  }
}

function postRedditLink(title, link, subreddit) {
  reddit.getSubreddit(subreddit).submitLink({
    title: title,
    url: link,
    sendReplies: false
  });
}

let postInterval = 28800000; // 8 hrs

setInterval(async () => {

  if (tracks.length <= 0) {
    tracks = await refreshTracksList();
  }

  if (tracks.length <= 0) {
    console.log('---\n', `[${getTimeStamp()}] No new tracks to post! Trying again at ${new Date(Date.now() + postInterval).toLocaleString()}`)
    return;
  }

  let trackAndId = tracks[tracks.length - 1].split(':');

  if (!postedTracks.includes(trackAndId[1])) {
    let url = await searchYoutube(tracks[tracks.length - 1].split('[')[0]);

    if (url != '') {
      // postRedditLink(trackAndId[0], url, 'test_automation');
      postRedditLink(trackAndId[0], url, 'Music');
      postRedditLink(trackAndId[0], url, 'listentothis');

      console.log('---\n', `[${getTimeStamp()}]`, 'Posted', trackAndId[0], `from ${url}`);

      postedTracks.push(trackAndId[1]);
      savePostedTracks();
    }
  } else {
    console.warn('Track', trackAndId, 'already posted; removing from playlist.')
  }

  removeTrackFromPlaylist(process.env.S_PLAYLIST, trackAndId[1]);
  tracks.pop();
}, postInterval + Math.floor(Math.random() * 3600000));

console.log(`Script started at ${getTimeStamp()}; first post will occur at ${new Date(Date.now() + postInterval).toLocaleString()} plus a random amount < 1 hr.`);